/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace PredictionMarket {
  export type PredictionDetailsStruct = {
    question: string;
    outcome1: string;
    outcome2: string;
    oracle: AddressLike;
    initialTokenValue: BigNumberish;
    yesTokenReserve: BigNumberish;
    noTokenReserve: BigNumberish;
    isReported: boolean;
    yesToken: AddressLike;
    noToken: AddressLike;
    winningToken: AddressLike;
    collateral: BigNumberish;
    lpTradingRevenue: BigNumberish;
    predictionMarketOwner: AddressLike;
    initialProbability: BigNumberish;
    percentageLocked: BigNumberish;
  };

  export type PredictionDetailsStructOutput = [
    question: string,
    outcome1: string,
    outcome2: string,
    oracle: string,
    initialTokenValue: bigint,
    yesTokenReserve: bigint,
    noTokenReserve: bigint,
    isReported: boolean,
    yesToken: string,
    noToken: string,
    winningToken: string,
    collateral: bigint,
    lpTradingRevenue: bigint,
    predictionMarketOwner: string,
    initialProbability: bigint,
    percentageLocked: bigint
  ] & {
    question: string;
    outcome1: string;
    outcome2: string;
    oracle: string;
    initialTokenValue: bigint;
    yesTokenReserve: bigint;
    noTokenReserve: bigint;
    isReported: boolean;
    yesToken: string;
    noToken: string;
    winningToken: string;
    collateral: bigint;
    lpTradingRevenue: bigint;
    predictionMarketOwner: string;
    initialProbability: bigint;
    percentageLocked: bigint;
  };
}

export interface PredictionMarketInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "addLiquidity"
      | "buyTokens"
      | "calculateTokensForPayment"
      | "getBuyPrice"
      | "getExpectedAuthor"
      | "getExpectedWorkflowId"
      | "getExpectedWorkflowName"
      | "getForwarderAddress"
      | "getPrediction"
      | "getSellPrice"
      | "i_initialTokenValue"
      | "i_initialYesProbability"
      | "i_noToken"
      | "i_oracle"
      | "i_paymentToken"
      | "i_percentageLocked"
      | "i_yesToken"
      | "initialize"
      | "onReport"
      | "owner"
      | "redeemWinningTokens"
      | "removeLiquidity"
      | "renounceOwnership"
      | "reportManually"
      | "requestSettlement"
      | "resolveMarketAndWithdraw"
      | "s_collateral"
      | "s_confidenceBps"
      | "s_evidenceURI"
      | "s_isReported"
      | "s_lpTradingRevenue"
      | "s_pendingInitialLiquidity"
      | "s_question"
      | "s_winningToken"
      | "sellTokens"
      | "setExpectedAuthor"
      | "setExpectedWorkflowId"
      | "setExpectedWorkflowName"
      | "setForwarderAddress"
      | "supportsInterface"
      | "transferOwnership"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ExpectedAuthorUpdated"
      | "ExpectedWorkflowIdUpdated"
      | "ExpectedWorkflowNameUpdated"
      | "ForwarderAddressUpdated"
      | "LiquidityAdded"
      | "LiquidityRemoved"
      | "MarketReported"
      | "MarketResolved"
      | "OwnershipTransferred"
      | "SecurityWarning"
      | "SettlementRequested"
      | "TokensPurchased"
      | "TokensSold"
      | "WinningTokensRedeemed"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "addLiquidity",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyTokens",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateTokensForPayment",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getBuyPrice",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getExpectedAuthor",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getExpectedWorkflowId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getExpectedWorkflowName",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getForwarderAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPrediction",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSellPrice",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "i_initialTokenValue",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "i_initialYesProbability",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "i_noToken", values?: undefined): string;
  encodeFunctionData(functionFragment: "i_oracle", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "i_paymentToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "i_percentageLocked",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "i_yesToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "onReport",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "redeemWinningTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidity",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reportManually",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "requestSettlement",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "resolveMarketAndWithdraw",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_collateral",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_confidenceBps",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_evidenceURI",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_isReported",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_lpTradingRevenue",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_pendingInitialLiquidity",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_question",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "s_winningToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sellTokens",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpectedAuthor",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpectedWorkflowId",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpectedWorkflowName",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setForwarderAddress",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "addLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "buyTokens", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "calculateTokensForPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBuyPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExpectedAuthor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExpectedWorkflowId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExpectedWorkflowName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getForwarderAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPrediction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSellPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "i_initialTokenValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "i_initialYesProbability",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "i_noToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "i_oracle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "i_paymentToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "i_percentageLocked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "i_yesToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "onReport", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemWinningTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reportManually",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestSettlement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resolveMarketAndWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "s_collateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "s_confidenceBps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "s_evidenceURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "s_isReported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "s_lpTradingRevenue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "s_pendingInitialLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "s_question", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "s_winningToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sellTokens", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setExpectedAuthor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpectedWorkflowId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpectedWorkflowName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setForwarderAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
}

export namespace ExpectedAuthorUpdatedEvent {
  export type InputTuple = [
    previousAuthor: AddressLike,
    newAuthor: AddressLike
  ];
  export type OutputTuple = [previousAuthor: string, newAuthor: string];
  export interface OutputObject {
    previousAuthor: string;
    newAuthor: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ExpectedWorkflowIdUpdatedEvent {
  export type InputTuple = [previousId: BytesLike, newId: BytesLike];
  export type OutputTuple = [previousId: string, newId: string];
  export interface OutputObject {
    previousId: string;
    newId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ExpectedWorkflowNameUpdatedEvent {
  export type InputTuple = [previousName: BytesLike, newName: BytesLike];
  export type OutputTuple = [previousName: string, newName: string];
  export interface OutputObject {
    previousName: string;
    newName: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ForwarderAddressUpdatedEvent {
  export type InputTuple = [
    previousForwarder: AddressLike,
    newForwarder: AddressLike
  ];
  export type OutputTuple = [previousForwarder: string, newForwarder: string];
  export interface OutputObject {
    previousForwarder: string;
    newForwarder: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LiquidityAddedEvent {
  export type InputTuple = [
    provider: AddressLike,
    amount: BigNumberish,
    tokensAmount: BigNumberish
  ];
  export type OutputTuple = [
    provider: string,
    amount: bigint,
    tokensAmount: bigint
  ];
  export interface OutputObject {
    provider: string;
    amount: bigint;
    tokensAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LiquidityRemovedEvent {
  export type InputTuple = [
    provider: AddressLike,
    amount: BigNumberish,
    tokensAmount: BigNumberish
  ];
  export type OutputTuple = [
    provider: string,
    amount: bigint,
    tokensAmount: bigint
  ];
  export interface OutputObject {
    provider: string;
    amount: bigint;
    tokensAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MarketReportedEvent {
  export type InputTuple = [
    oracle: AddressLike,
    winningOutcome: BigNumberish,
    winningToken: AddressLike
  ];
  export type OutputTuple = [
    oracle: string,
    winningOutcome: bigint,
    winningToken: string
  ];
  export interface OutputObject {
    oracle: string;
    winningOutcome: bigint;
    winningToken: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MarketResolvedEvent {
  export type InputTuple = [resolver: AddressLike, payoutAmount: BigNumberish];
  export type OutputTuple = [resolver: string, payoutAmount: bigint];
  export interface OutputObject {
    resolver: string;
    payoutAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SecurityWarningEvent {
  export type InputTuple = [message: string];
  export type OutputTuple = [message: string];
  export interface OutputObject {
    message: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SettlementRequestedEvent {
  export type InputTuple = [marketId: BigNumberish, question: string];
  export type OutputTuple = [marketId: bigint, question: string];
  export interface OutputObject {
    marketId: bigint;
    question: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokensPurchasedEvent {
  export type InputTuple = [
    buyer: AddressLike,
    outcome: BigNumberish,
    amount: BigNumberish,
    paymentAmount: BigNumberish
  ];
  export type OutputTuple = [
    buyer: string,
    outcome: bigint,
    amount: bigint,
    paymentAmount: bigint
  ];
  export interface OutputObject {
    buyer: string;
    outcome: bigint;
    amount: bigint;
    paymentAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokensSoldEvent {
  export type InputTuple = [
    seller: AddressLike,
    outcome: BigNumberish,
    amount: BigNumberish,
    paymentAmount: BigNumberish
  ];
  export type OutputTuple = [
    seller: string,
    outcome: bigint,
    amount: bigint,
    paymentAmount: bigint
  ];
  export interface OutputObject {
    seller: string;
    outcome: bigint;
    amount: bigint;
    paymentAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WinningTokensRedeemedEvent {
  export type InputTuple = [
    redeemer: AddressLike,
    amount: BigNumberish,
    payoutAmount: BigNumberish
  ];
  export type OutputTuple = [
    redeemer: string,
    amount: bigint,
    payoutAmount: bigint
  ];
  export interface OutputObject {
    redeemer: string;
    amount: bigint;
    payoutAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface PredictionMarket extends BaseContract {
  connect(runner?: ContractRunner | null): PredictionMarket;
  waitForDeployment(): Promise<this>;

  interface: PredictionMarketInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  addLiquidity: TypedContractMethod<
    [_amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  buyTokens: TypedContractMethod<
    [
      _outcome: BigNumberish,
      _paymentAmount: BigNumberish,
      _minTokensOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  calculateTokensForPayment: TypedContractMethod<
    [_outcome: BigNumberish, _paymentAmount: BigNumberish],
    [bigint],
    "view"
  >;

  getBuyPrice: TypedContractMethod<
    [_outcome: BigNumberish, _tradingAmount: BigNumberish],
    [bigint],
    "view"
  >;

  getExpectedAuthor: TypedContractMethod<[], [string], "view">;

  getExpectedWorkflowId: TypedContractMethod<[], [string], "view">;

  getExpectedWorkflowName: TypedContractMethod<[], [string], "view">;

  getForwarderAddress: TypedContractMethod<[], [string], "view">;

  getPrediction: TypedContractMethod<
    [],
    [PredictionMarket.PredictionDetailsStructOutput],
    "view"
  >;

  getSellPrice: TypedContractMethod<
    [_outcome: BigNumberish, _tradingAmount: BigNumberish],
    [bigint],
    "view"
  >;

  i_initialTokenValue: TypedContractMethod<[], [bigint], "view">;

  i_initialYesProbability: TypedContractMethod<[], [bigint], "view">;

  i_noToken: TypedContractMethod<[], [string], "view">;

  i_oracle: TypedContractMethod<[], [string], "view">;

  i_paymentToken: TypedContractMethod<[], [string], "view">;

  i_percentageLocked: TypedContractMethod<[], [bigint], "view">;

  i_yesToken: TypedContractMethod<[], [string], "view">;

  initialize: TypedContractMethod<[], [void], "nonpayable">;

  onReport: TypedContractMethod<
    [metadata: BytesLike, report: BytesLike],
    [void],
    "nonpayable"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  redeemWinningTokens: TypedContractMethod<
    [_amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  removeLiquidity: TypedContractMethod<
    [_amountToWithdraw: BigNumberish],
    [void],
    "nonpayable"
  >;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  reportManually: TypedContractMethod<
    [_winningOutcome: BigNumberish],
    [void],
    "nonpayable"
  >;

  requestSettlement: TypedContractMethod<
    [_marketId: BigNumberish],
    [void],
    "nonpayable"
  >;

  resolveMarketAndWithdraw: TypedContractMethod<[], [bigint], "nonpayable">;

  s_collateral: TypedContractMethod<[], [bigint], "view">;

  s_confidenceBps: TypedContractMethod<[], [bigint], "view">;

  s_evidenceURI: TypedContractMethod<[], [string], "view">;

  s_isReported: TypedContractMethod<[], [boolean], "view">;

  s_lpTradingRevenue: TypedContractMethod<[], [bigint], "view">;

  s_pendingInitialLiquidity: TypedContractMethod<[], [bigint], "view">;

  s_question: TypedContractMethod<[], [string], "view">;

  s_winningToken: TypedContractMethod<[], [string], "view">;

  sellTokens: TypedContractMethod<
    [
      _outcome: BigNumberish,
      _tradingAmount: BigNumberish,
      _minRefund: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setExpectedAuthor: TypedContractMethod<
    [_author: AddressLike],
    [void],
    "nonpayable"
  >;

  setExpectedWorkflowId: TypedContractMethod<
    [_id: BytesLike],
    [void],
    "nonpayable"
  >;

  setExpectedWorkflowName: TypedContractMethod<
    [_name: string],
    [void],
    "nonpayable"
  >;

  setForwarderAddress: TypedContractMethod<
    [_forwarder: AddressLike],
    [void],
    "nonpayable"
  >;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "addLiquidity"
  ): TypedContractMethod<[_amount: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "buyTokens"
  ): TypedContractMethod<
    [
      _outcome: BigNumberish,
      _paymentAmount: BigNumberish,
      _minTokensOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "calculateTokensForPayment"
  ): TypedContractMethod<
    [_outcome: BigNumberish, _paymentAmount: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getBuyPrice"
  ): TypedContractMethod<
    [_outcome: BigNumberish, _tradingAmount: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getExpectedAuthor"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getExpectedWorkflowId"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getExpectedWorkflowName"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getForwarderAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getPrediction"
  ): TypedContractMethod<
    [],
    [PredictionMarket.PredictionDetailsStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getSellPrice"
  ): TypedContractMethod<
    [_outcome: BigNumberish, _tradingAmount: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "i_initialTokenValue"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "i_initialYesProbability"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "i_noToken"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "i_oracle"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "i_paymentToken"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "i_percentageLocked"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "i_yesToken"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "onReport"
  ): TypedContractMethod<
    [metadata: BytesLike, report: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "redeemWinningTokens"
  ): TypedContractMethod<[_amount: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "removeLiquidity"
  ): TypedContractMethod<
    [_amountToWithdraw: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "reportManually"
  ): TypedContractMethod<[_winningOutcome: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "requestSettlement"
  ): TypedContractMethod<[_marketId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "resolveMarketAndWithdraw"
  ): TypedContractMethod<[], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "s_collateral"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "s_confidenceBps"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "s_evidenceURI"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "s_isReported"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "s_lpTradingRevenue"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "s_pendingInitialLiquidity"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "s_question"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "s_winningToken"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "sellTokens"
  ): TypedContractMethod<
    [
      _outcome: BigNumberish,
      _tradingAmount: BigNumberish,
      _minRefund: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setExpectedAuthor"
  ): TypedContractMethod<[_author: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setExpectedWorkflowId"
  ): TypedContractMethod<[_id: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setExpectedWorkflowName"
  ): TypedContractMethod<[_name: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setForwarderAddress"
  ): TypedContractMethod<[_forwarder: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;

  getEvent(
    key: "ExpectedAuthorUpdated"
  ): TypedContractEvent<
    ExpectedAuthorUpdatedEvent.InputTuple,
    ExpectedAuthorUpdatedEvent.OutputTuple,
    ExpectedAuthorUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ExpectedWorkflowIdUpdated"
  ): TypedContractEvent<
    ExpectedWorkflowIdUpdatedEvent.InputTuple,
    ExpectedWorkflowIdUpdatedEvent.OutputTuple,
    ExpectedWorkflowIdUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ExpectedWorkflowNameUpdated"
  ): TypedContractEvent<
    ExpectedWorkflowNameUpdatedEvent.InputTuple,
    ExpectedWorkflowNameUpdatedEvent.OutputTuple,
    ExpectedWorkflowNameUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ForwarderAddressUpdated"
  ): TypedContractEvent<
    ForwarderAddressUpdatedEvent.InputTuple,
    ForwarderAddressUpdatedEvent.OutputTuple,
    ForwarderAddressUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "LiquidityAdded"
  ): TypedContractEvent<
    LiquidityAddedEvent.InputTuple,
    LiquidityAddedEvent.OutputTuple,
    LiquidityAddedEvent.OutputObject
  >;
  getEvent(
    key: "LiquidityRemoved"
  ): TypedContractEvent<
    LiquidityRemovedEvent.InputTuple,
    LiquidityRemovedEvent.OutputTuple,
    LiquidityRemovedEvent.OutputObject
  >;
  getEvent(
    key: "MarketReported"
  ): TypedContractEvent<
    MarketReportedEvent.InputTuple,
    MarketReportedEvent.OutputTuple,
    MarketReportedEvent.OutputObject
  >;
  getEvent(
    key: "MarketResolved"
  ): TypedContractEvent<
    MarketResolvedEvent.InputTuple,
    MarketResolvedEvent.OutputTuple,
    MarketResolvedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "SecurityWarning"
  ): TypedContractEvent<
    SecurityWarningEvent.InputTuple,
    SecurityWarningEvent.OutputTuple,
    SecurityWarningEvent.OutputObject
  >;
  getEvent(
    key: "SettlementRequested"
  ): TypedContractEvent<
    SettlementRequestedEvent.InputTuple,
    SettlementRequestedEvent.OutputTuple,
    SettlementRequestedEvent.OutputObject
  >;
  getEvent(
    key: "TokensPurchased"
  ): TypedContractEvent<
    TokensPurchasedEvent.InputTuple,
    TokensPurchasedEvent.OutputTuple,
    TokensPurchasedEvent.OutputObject
  >;
  getEvent(
    key: "TokensSold"
  ): TypedContractEvent<
    TokensSoldEvent.InputTuple,
    TokensSoldEvent.OutputTuple,
    TokensSoldEvent.OutputObject
  >;
  getEvent(
    key: "WinningTokensRedeemed"
  ): TypedContractEvent<
    WinningTokensRedeemedEvent.InputTuple,
    WinningTokensRedeemedEvent.OutputTuple,
    WinningTokensRedeemedEvent.OutputObject
  >;

  filters: {
    "ExpectedAuthorUpdated(address,address)": TypedContractEvent<
      ExpectedAuthorUpdatedEvent.InputTuple,
      ExpectedAuthorUpdatedEvent.OutputTuple,
      ExpectedAuthorUpdatedEvent.OutputObject
    >;
    ExpectedAuthorUpdated: TypedContractEvent<
      ExpectedAuthorUpdatedEvent.InputTuple,
      ExpectedAuthorUpdatedEvent.OutputTuple,
      ExpectedAuthorUpdatedEvent.OutputObject
    >;

    "ExpectedWorkflowIdUpdated(bytes32,bytes32)": TypedContractEvent<
      ExpectedWorkflowIdUpdatedEvent.InputTuple,
      ExpectedWorkflowIdUpdatedEvent.OutputTuple,
      ExpectedWorkflowIdUpdatedEvent.OutputObject
    >;
    ExpectedWorkflowIdUpdated: TypedContractEvent<
      ExpectedWorkflowIdUpdatedEvent.InputTuple,
      ExpectedWorkflowIdUpdatedEvent.OutputTuple,
      ExpectedWorkflowIdUpdatedEvent.OutputObject
    >;

    "ExpectedWorkflowNameUpdated(bytes10,bytes10)": TypedContractEvent<
      ExpectedWorkflowNameUpdatedEvent.InputTuple,
      ExpectedWorkflowNameUpdatedEvent.OutputTuple,
      ExpectedWorkflowNameUpdatedEvent.OutputObject
    >;
    ExpectedWorkflowNameUpdated: TypedContractEvent<
      ExpectedWorkflowNameUpdatedEvent.InputTuple,
      ExpectedWorkflowNameUpdatedEvent.OutputTuple,
      ExpectedWorkflowNameUpdatedEvent.OutputObject
    >;

    "ForwarderAddressUpdated(address,address)": TypedContractEvent<
      ForwarderAddressUpdatedEvent.InputTuple,
      ForwarderAddressUpdatedEvent.OutputTuple,
      ForwarderAddressUpdatedEvent.OutputObject
    >;
    ForwarderAddressUpdated: TypedContractEvent<
      ForwarderAddressUpdatedEvent.InputTuple,
      ForwarderAddressUpdatedEvent.OutputTuple,
      ForwarderAddressUpdatedEvent.OutputObject
    >;

    "LiquidityAdded(address,uint256,uint256)": TypedContractEvent<
      LiquidityAddedEvent.InputTuple,
      LiquidityAddedEvent.OutputTuple,
      LiquidityAddedEvent.OutputObject
    >;
    LiquidityAdded: TypedContractEvent<
      LiquidityAddedEvent.InputTuple,
      LiquidityAddedEvent.OutputTuple,
      LiquidityAddedEvent.OutputObject
    >;

    "LiquidityRemoved(address,uint256,uint256)": TypedContractEvent<
      LiquidityRemovedEvent.InputTuple,
      LiquidityRemovedEvent.OutputTuple,
      LiquidityRemovedEvent.OutputObject
    >;
    LiquidityRemoved: TypedContractEvent<
      LiquidityRemovedEvent.InputTuple,
      LiquidityRemovedEvent.OutputTuple,
      LiquidityRemovedEvent.OutputObject
    >;

    "MarketReported(address,uint8,address)": TypedContractEvent<
      MarketReportedEvent.InputTuple,
      MarketReportedEvent.OutputTuple,
      MarketReportedEvent.OutputObject
    >;
    MarketReported: TypedContractEvent<
      MarketReportedEvent.InputTuple,
      MarketReportedEvent.OutputTuple,
      MarketReportedEvent.OutputObject
    >;

    "MarketResolved(address,uint256)": TypedContractEvent<
      MarketResolvedEvent.InputTuple,
      MarketResolvedEvent.OutputTuple,
      MarketResolvedEvent.OutputObject
    >;
    MarketResolved: TypedContractEvent<
      MarketResolvedEvent.InputTuple,
      MarketResolvedEvent.OutputTuple,
      MarketResolvedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "SecurityWarning(string)": TypedContractEvent<
      SecurityWarningEvent.InputTuple,
      SecurityWarningEvent.OutputTuple,
      SecurityWarningEvent.OutputObject
    >;
    SecurityWarning: TypedContractEvent<
      SecurityWarningEvent.InputTuple,
      SecurityWarningEvent.OutputTuple,
      SecurityWarningEvent.OutputObject
    >;

    "SettlementRequested(uint256,string)": TypedContractEvent<
      SettlementRequestedEvent.InputTuple,
      SettlementRequestedEvent.OutputTuple,
      SettlementRequestedEvent.OutputObject
    >;
    SettlementRequested: TypedContractEvent<
      SettlementRequestedEvent.InputTuple,
      SettlementRequestedEvent.OutputTuple,
      SettlementRequestedEvent.OutputObject
    >;

    "TokensPurchased(address,uint8,uint256,uint256)": TypedContractEvent<
      TokensPurchasedEvent.InputTuple,
      TokensPurchasedEvent.OutputTuple,
      TokensPurchasedEvent.OutputObject
    >;
    TokensPurchased: TypedContractEvent<
      TokensPurchasedEvent.InputTuple,
      TokensPurchasedEvent.OutputTuple,
      TokensPurchasedEvent.OutputObject
    >;

    "TokensSold(address,uint8,uint256,uint256)": TypedContractEvent<
      TokensSoldEvent.InputTuple,
      TokensSoldEvent.OutputTuple,
      TokensSoldEvent.OutputObject
    >;
    TokensSold: TypedContractEvent<
      TokensSoldEvent.InputTuple,
      TokensSoldEvent.OutputTuple,
      TokensSoldEvent.OutputObject
    >;

    "WinningTokensRedeemed(address,uint256,uint256)": TypedContractEvent<
      WinningTokensRedeemedEvent.InputTuple,
      WinningTokensRedeemedEvent.OutputTuple,
      WinningTokensRedeemedEvent.OutputObject
    >;
    WinningTokensRedeemed: TypedContractEvent<
      WinningTokensRedeemedEvent.InputTuple,
      WinningTokensRedeemedEvent.OutputTuple,
      WinningTokensRedeemedEvent.OutputObject
    >;
  };
}
